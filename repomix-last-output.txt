This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2026-02-13 12:04:13

# File Summary

## Purpose:

This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format:

The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
   a. A header with the file path (## File: path/to/file)
   b. The full contents of the file in a code block

## Usage Guidelines:

- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes:

- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

## Additional Information:

For more information about Repomix, visit: https://github.com/andersonby/python-repomix


# Repository Structure

```
backend
  API
    controller
      categoryController.ts
      noteController.ts
    routes
      notesRoutes.ts
  init.sql
  notesManagement
    BO
      CategoryBO.ts
      NoteBO.ts
    DA
      dao
        NoteDAO.ts
        NoteCategoryDAO.ts
        CategoryDAO.ts
      daoImpl
        NoteCategoryDAOImpl.ts
        CategoryDAOImpl.ts
        NoteDAOImpl.ts
  api.http
  package.json
  DBManager
    db
      DAOImpl.ts
    config
      DBManager.ts
    DBManagerMain.ts
  app.ts
setup.sh
frontend
  todo-app
    README.md
    index.html
    src
      main.jsx
      app
        store
          store.js
        routes
          index.jsx
        layouts
          AppLayout.jsx
        App.jsx
      features
        tasks
          store
            categoriesSlice.js
            tasksSlice.js
          api
            tasksApi.js
            categoriesApi.js
          pages
            ArchivePage.jsx
            TasksPage.jsx
          components
            NavBar.jsx
            TaskList.jsx
            TaskComponent.jsx
            AddCategoryModal.jsx
            AddTaskForm.jsx
            EditTaskModal.jsx
    vite.config.js
    .gitignore
    eslint.config.js
    package.json
README.md
.gitignore
```

# Repository Files


## backend/API/controller/categoryController.ts

```typescript
import { CategoryBO } from "../../notesManagement/BO/CategoryBO.js";
import { Request, Response } from "express";

export class CategoryController {
    private categoryBO: CategoryBO;

    constructor() {
        this.categoryBO = new CategoryBO();

        // Vincula los métodos. Esto para no perder el contexto del this (su objeto especifico.)
        this.listCategories = this.listCategories.bind(this);
        this.insertCategory = this.insertCategory.bind(this);
        this.deleteCategory = this.deleteCategory.bind(this);
    }

    async listCategories(req: Request, res: Response): Promise<void> {
        try {
            const categories = await this.categoryBO.list_categories();
            res.status(200).json({
                success: true,
                data: categories
            });
        } catch (error) {
            res.status(500).json({
                success: false,
                message: error
            });
        }
    };

    async insertCategory(req: Request, res: Response): Promise<void> {
        try {
            const { name } = req.body;

            const id = await this.categoryBO.insert_category(name)

            res.status(201).json({
                success: true,
                data: { id }
            });
        } catch (error) {
            res.status(400).json({
                success: false,
                message: error
            });
        }
    };

    async deleteCategory(req: Request, res: Response): Promise<void> {
        try {
            const { id } = req.params;
            const categoryId = parseInt(id);

            const affectedRows = await this.categoryBO.delete_category(categoryId);

            if (affectedRows === 0) {
                res.status(404).json({
                    success: false,
                    message: 'Nota no encontrada'
                });
                return;
            }

            res.status(200).json({
                success: true,
                message: 'Nota eliminada'
            });
        } catch (error) {
            res.status(500).json({
                success: false,
                message: error 
            });
        }
    };
}
```

## backend/API/controller/noteController.ts

```typescript
import { Request, Response } from 'express'; // Necesario importar estos types en TS.
import { NoteBO } from '../../notesManagement/BO/NoteBO.js';
import { NoteInput, NoteUpdate } from '../../notesManagement/DA/dao/NoteDAO.js';

export class NoteController {
    private noteBO: NoteBO;

    constructor() {
        this.noteBO = new NoteBO();

        // Vincula los métodos. Esto para no perder el contexto del this (su objeto especifico.)
        this.listNotes = this.listNotes.bind(this);
        this.insertNote = this.insertNote.bind(this);
        this.updateNote = this.updateNote.bind(this);
        this.deleteNote = this.deleteNote.bind(this);
    }

    async listNotes(req: Request, res: Response): Promise<void> {
        try {
            const notes = await this.noteBO.listNotesWithCategory();
            res.status(200).json({
                success: true,
                data: notes
            });
        } catch (error) {
            res.status(500).json({
                success: false,
                message: error
            });
        }
    };

    async insertNote(req: Request, res: Response): Promise<void> {
        try {
            const { title, content, isArchived, idCategory } = req.body;

            const id = await this.noteBO.insert_note(title, content, isArchived, idCategory);

            res.status(201).json({
                success: true,
                data: { id }
            });
        } catch (error) {
            res.status(400).json({
                success: false,
                message: error
            });
        }
    };

    async updateNote(req: Request, res: Response): Promise<void> {
        try {
            const { id } = req.params;
            const noteId = parseInt(id); // Siempre se pasan como string.
            const updates: NoteUpdate = req.body;

            const affectedRows = await this.noteBO.update_note(noteId, updates);

            // No se ha actualizado. 
            if (affectedRows === 0) {
                res.status(404).json({
                    success: false,
                    message: 'Nota no encontrada'
                });
                return;
            }

            // Caso contrario, se indica que fue actualizado.
            res.status(200).json({
                success: true,
                message: 'Nota actualizada'
            });
        } catch (error) {
            res.status(400).json({
                success: false,
                message: error
            });
        }
    };

    async deleteNote(req: Request, res: Response): Promise<void> {
        try {
            const { id } = req.params;
            const noteId = parseInt(id);

            const affectedRows = await this.noteBO.delete_note(noteId);

            if (affectedRows === 0) {
                res.status(404).json({
                    success: false,
                    message: 'Nota no encontrada'
                });
                return;
            }

            res.status(200).json({
                success: true,
                message: 'Nota eliminada'
            });
        } catch (error) {
            res.status(500).json({
                success: false,
                message: error instanceof Error ? error.message : 'Error desconocido'
            });
        }
    };
}
```

## backend/API/routes/notesRoutes.ts

```typescript
import { Router } from 'express';
// Aqui es donde usaremos los metodos BO.
import { NoteController } from '../controller/noteController.js';
import { CategoryController } from '../controller/categoryController.js';

// Ahora si, procedemos primero con definir las rutas.
export const notesRouter: Router = Router(); // Declaramos, ahora definimos las rutas
export const categoriesRouter : Router = Router()
// Controlador de notas
const noteController: NoteController = new NoteController();
const categoryController: CategoryController = new CategoryController();

// Rutas de las notas
notesRouter.get("/", noteController.listNotes);
notesRouter.post("/", noteController.insertNote);
notesRouter.put("/:id", noteController.updateNote);
notesRouter.delete("/:id", noteController.deleteNote);

// Definimos las rutas para las categorías
categoriesRouter.get("/", categoryController.listCategories);
categoriesRouter.post("/", categoryController.insertCategory);
categoriesRouter.delete("/:id", categoryController.deleteCategory);
```

## backend/init.sql

```sql
-- ============================================
-- CREATE DATABASE IF NOT EXISTS
-- ============================================
CREATE DATABASE IF NOT EXISTS notes_app;
USE notes_app;

-- ============================================
-- DROPS (Remove tables if they exist)
-- ============================================

-- First the intermediate table (has foreign keys)
DROP TABLE IF EXISTS note_categories;

-- Then the main tables
DROP TABLE IF EXISTS notes;
DROP TABLE IF EXISTS categories;

-- ============================================
-- TABLE CREATION
-- ============================================

-- Categories table
CREATE TABLE categories (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(255) NOT NULL UNIQUE,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- Notes table
CREATE TABLE notes (
    id INT PRIMARY KEY AUTO_INCREMENT,
    title VARCHAR(255) NOT NULL,
    content TEXT,
    is_archived TINYINT(1) DEFAULT 0,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- Intermediate table (1 to 1 relationship: one note has ONE category)
CREATE TABLE note_categories (
    note_id INT NOT NULL UNIQUE,
    category_id INT NOT NULL,
    assigned_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (note_id),
    FOREIGN KEY (note_id) REFERENCES notes(id) ON DELETE CASCADE,
    FOREIGN KEY (category_id) REFERENCES categories(id) ON DELETE CASCADE
);

-- ============================================
-- INDEXES (To improve performance)
-- ============================================

CREATE INDEX idx_notes_archived ON notes(is_archived);
CREATE INDEX idx_notes_created ON notes(created_at);
CREATE INDEX idx_note_categories_category ON note_categories(category_id);

-- ============================================
-- SAMPLE DATA - CATEGORIES
-- ============================================

INSERT INTO categories (name) VALUES
('Work'),
('Personal'),
('Studies'),
('Projects'),
('Ideas'),
('Shopping');

-- ============================================
-- SAMPLE DATA - NOTES
-- ============================================

INSERT INTO notes (title, content, is_archived, created_at) VALUES
('Client meeting', 'Prepare presentation for XYZ project. Include mockups and timeline.', 0, '2025-10-01 09:00:00'),
('Buy groceries', 'Milk, eggs, bread, fruits, vegetables', 0, '2025-10-05 14:30:00'),
('Class notes', 'Chapter 5: Data structures. Binary trees and graphs.', 0, '2025-10-07 16:00:00'),
('Mobile app', 'Research frameworks: React Native vs Flutter. Compare advantages.', 0, '2025-10-08 11:00:00'),
('New feature', 'Add push notification system to the application', 0, '2025-10-09 10:00:00'),
('Pasta recipe', 'Carbonara pasta: bacon, eggs, parmesan cheese, pepper', 1, '2025-09-15 19:00:00'),
('Production bug', '500 error in /api/users endpoint. Review data validation', 0, '2025-10-09 08:30:00'),
('Maria\'s birthday', 'Buy gift and organize dinner for October 15th', 0, '2025-10-02 12:00:00'),
('Recommended book', 'Clean Code by Robert Martin. Read chapters 1-3', 0, '2025-10-06 20:00:00'),
('Gym routine', 'Exercise routine: Monday and Wednesday legs, Tuesday and Thursday arms', 1, '2025-09-20 07:00:00');

-- ============================================
-- RELATIONSHIPS - ASSIGN ONE CATEGORY TO EACH NOTE
-- ============================================

-- Note 1 (Client meeting) -> Work
INSERT INTO note_categories (note_id, category_id) VALUES (1, 1);

-- Note 2 (Buy groceries) -> Shopping
INSERT INTO note_categories (note_id, category_id) VALUES (2, 6);

-- Note 3 (Class notes) -> Studies
INSERT INTO note_categories (note_id, category_id) VALUES (3, 3);

-- Note 4 (Mobile app) -> Projects
INSERT INTO note_categories (note_id, category_id) VALUES (4, 4);

-- Note 5 (New feature) -> Work
INSERT INTO note_categories (note_id, category_id) VALUES (5, 1);

-- Note 6 (Pasta recipe) -> Personal
INSERT INTO note_categories (note_id, category_id) VALUES (6, 2);

-- Note 7 (Production bug) -> Work
INSERT INTO note_categories (note_id, category_id) VALUES (7, 1);

-- Note 8 (Maria's birthday) -> Personal
INSERT INTO note_categories (note_id, category_id) VALUES (8, 2);

-- Note 9 (Recommended book) -> Studies
INSERT INTO note_categories (note_id, category_id) VALUES (9, 3);

-- Note 10 (Gym routine) -> Personal
INSERT INTO note_categories (note_id, category_id) VALUES (10, 2);


SELECT * FROM categories;
```

## backend/notesManagement/BO/CategoryBO.ts

```typescript
import { Category } from "../DA/dao/CategoryDAO.js";
import { CategoryDAOImpl } from "../DA/daoImpl/CategoryDAOImpl.js";


export class CategoryBO {
    private categoryDAO: CategoryDAOImpl;

    constructor(){
        this.categoryDAO = new CategoryDAOImpl();
    }

    // Ahora los metodos.
    public async list_categories(): Promise<Category[]> {
        return this.categoryDAO.list_all();
    }

    public async insert_category(name: string) {
        return this.categoryDAO.insert_category({
            name,
            createdAt: new Date()
        })
    }

    public async delete_category(id: number): Promise<number>{
        if(id === null){
            throw new Error("No se ha especificado que elemeto eliminar");
        }
        return this.categoryDAO.delete_category(id)
    }



}
```

## backend/notesManagement/BO/NoteBO.ts

```typescript
import { Note, NoteUpdate } from "../DA/dao/NoteDAO";
import { NoteCategoryDAOImpl } from "../DA/daoImpl/NoteCategoryDAOImpl.js";
import { NoteDAOImpl } from "../DA/daoImpl/NoteDAOImpl.js";

// Tipo extendido para notas con su categoryId
export interface NoteWithCategoryId extends Note {
    categoryId: number | null;
}

export class NoteBO {
    private noteDAO: NoteDAOImpl;
    private noteCategoryDAO: NoteCategoryDAOImpl;
    constructor() {
        this.noteDAO = new NoteDAOImpl(); // Instanciamos.
        this.noteCategoryDAO = new NoteCategoryDAOImpl();
    }

    public async listNotes(): Promise<Note[]> {
        return this.noteDAO.listAll()
    }

    public async listNotesWithCategory(): Promise<NoteWithCategoryId[]> {
        const notes = await this.noteDAO.listAll(); // De la tabla Notes
        const relations = await this.noteCategoryDAO.listAll(); // De la tabla intermedia

        // Crear un mapa para búsqueda rápida: noteId -> categoryId
        const categoryMap = new Map<number, number>();
        relations.forEach(rel => {
            categoryMap.set(rel.noteId, rel.categoryId);
        });

        // Enlazar cada nota con su categoryId
        return notes.map(note => ({
            ...note,
            categoryId: note.id ? categoryMap.get(note.id) ?? null : null
        }));
    }

    public async insert_note(title: string, content: string, isArchived: boolean, idCategory: number, createdAt?: Date) {
        return this.noteDAO.insert_note({
            title,
            content,
            isArchived,
            createdAt: createdAt ?? new Date(),
            idCategory
        });
    }

    // Ahora el update. El API mandara el ID del elemento a modificarse, y tambien un body. Este sera de tipo NoteInput
    public async update_note(id: number, updates: NoteUpdate): Promise<number> {
        // Validamos que al menos un campo esté presente para actualizar
        if (Object.keys(updates).length === 0) {
            throw new Error("Debe proporcionar al menos un campo para actualizar");
        }

        const result = await this.noteDAO.update_note(id, updates);

        // Verificamos si realmente se actualizó algo
        if (result === 0) {
            throw new Error(`No se encontró una nota con el ID ${id}`);
        }

        return result;
    }

    public async delete_note(id: number): Promise<number> {
        if (id === null) {
            throw new Error("No se ha especificado que elemento eliminar");
        }
        return this.noteDAO.delete_note(id);
    }


}
```

## backend/notesManagement/DA/dao/NoteDAO.ts

```typescript
import { RowDataPacket } from "mysql2/promise";

// Plantilla de las notas (tareas)
export interface Note extends RowDataPacket {
    id: number | null;
    title: string | null;
    content: string | null;
    isArchived: boolean | null;
    createdAt: Date;
} 

// Este type se va a utilizar para todo lo que tenga que ver con inserciones u otros.
// Cuando se le manda el NoteInput, este debe de contar tambien con un id de la categoria que le corresponda.
export interface NoteInput {
    title: string;
    content: string;
    isArchived: boolean;  
    idCategory: number;
    createdAt: Date;  
}

// Ahora otro tipo que sera Update.
export interface NoteUpdate {
    title?: string;        // El signo ? significa que es opcional
    content?: string;
    isArchived?: boolean;
    // No se incluye el createdAt porque nunca debe modificarse
    // Tampoco incluimos id porque eso se pasa como parámetro separado
    // Pero si incluimos el idCategory. Tiene sentido pues puede que se desee cmbiar
    idcategory?: number;
}

// Ahora procedemos con la interfaz DAO
export interface NoteDAO {
    listAll(): Promise<Note[]>;
    
    insert_note(note: NoteInput): Promise<number>;
    
    update_note(id: number, note: NoteInput): Promise<number>;

    // Ahora procederemos con el delete.
    delete_note(id: number): Promise<number>;
    
}
```

## backend/notesManagement/DA/dao/NoteCategoryDAO.ts

```typescript
import { RowDataPacket } from "mysql2/promise";

// Entidad simple para la tabla intermedia
export interface NoteCategory extends RowDataPacket {
    noteId: number;
    categoryId: number;
}

// Interfaz del DAO - solo listar
export interface NoteCategoryDAO {
    listAll(): Promise<NoteCategory[]>;
}
```

## backend/notesManagement/DA/dao/CategoryDAO.ts

```typescript
// Para las categorias, tambien estas deben de seguir lo de create - delete. No piden UPDATE
// Creamos 2 interfaces.

import { RowDataPacket } from "mysql2";

// Plantilla de las notas (category)
export interface Category extends RowDataPacket {
    id: number | null;
    name: string | null;
    created_at: Date;
} 

// Este type se va a utilizar para todo lo que tenga que ver con inserciones u otros.
export interface CategoryInput {
    name: string;
    createdAt: Date;    
}

export interface CategoryDAO {
    list_all(): Promise<Category[]>;

    insert_category(category: CategoryInput): Promise<number>;

    delete_category(id: number): Promise<number>;


}
```

## backend/notesManagement/DA/daoImpl/NoteCategoryDAOImpl.ts

```typescript
import { DAOImpl } from "../../../DBManager/db/DAOImpl.js";
import { NoteCategory, NoteCategoryDAO } from "../dao/NoteCategoryDAO";

export class NoteCategoryDAOImpl extends DAOImpl implements NoteCategoryDAO {
    
    constructor() {
        super("note_categories");
    }

    protected get_atributes_list(): string {
        return "note_id AS noteId, category_id AS categoryId";
    }

    public async listAll(): Promise<NoteCategory[]> {
        return await this.list<NoteCategory>();
    }

    // Métodos abstractos requeridos (no se usan pero son obligatorios)
    protected generate_sql_insert(): string {
        return "";
    }

    protected get_values_for_insert(): any[] {
        return [];
    }

    protected generate_sql_update(): string {
        return "";
    }

    protected get_values_for_update(): any[] {
        return [];
    }

    protected generate_sql_delete(): string {
        return "";
    }

    protected get_values_for_delete(): any[] {
        return [];
    }

    protected async execute_additional_operations(insertedId: number): Promise<void> {
        // No necesario
    }
}
```

## backend/notesManagement/DA/daoImpl/CategoryDAOImpl.ts

```typescript
import { DAOImpl } from "../../../DBManager/db/DAOImpl.js";
import { Category, CategoryDAO, CategoryInput } from "../dao/CategoryDAO.js";

export class CategoryDAOImpl extends DAOImpl implements CategoryDAO {
    
    
    private category: CategoryInput | null;
    private categoryId: number | null;

    constructor() {
        super("categories");
        this.category = null;
        this.categoryId = null;
    }

    protected get_atributes_list(): string {
        return "id, name, created_at";
    }

    protected generate_sql_insert(): string {
        return "INSERT INTO categories (name, created_at) VALUES (?, ?)";
    }

    protected get_values_for_insert(): any[] {
        if (!this.category) throw new Error("No hay data para insertar");
        return [this.category.name, this.category.createdAt];
    }


    protected generate_sql_delete(): string {
        return "DELETE FROM categories WHERE id = ?";
    }

    protected get_values_for_delete(): any[] {
        if (this.categoryId === null) throw new Error("No se cuenta con ID para eliminar");
        return [this.categoryId]; // Lo inserta a los placeholders del SQL.
    }

    async list_all(): Promise<Category[]> {
        return this.list<Category>();
    }

    async insert_category(category: CategoryInput): Promise<number> {
        this.category = category;
        return super.insert()
    }

    async delete_category(id: number): Promise<number> {
        this.categoryId = id;
        return super.delete();
    }


    // Metodos no definidos. El enunciado no pide que el usuario pueda editar categorias.
    protected generate_sql_update(): string {
        throw new Error("Method not implemented.");
    }
    protected get_values_for_update(): any[] {
        throw new Error("Method not implemented.");
    }

    // Tampoco cuenta con metodos intermedios
    protected execute_additional_operations(insertedId: number): Promise<void> {
        return Promise.resolve(); // Devuelve un promise resolved, como un Pass.
    }
}
```

## backend/notesManagement/DA/daoImpl/NoteDAOImpl.ts

```typescript
import { DAOImpl } from "../../../DBManager/db/DAOImpl.js";
import { Note, NoteDAO, NoteInput, NoteUpdate } from "../dao/NoteDAO";

export class NoteDAOImpl extends DAOImpl implements NoteDAO {
    
    private note: NoteInput | null;
    private noteUpdate: NoteUpdate | null;
    private noteId: number | null;

    constructor() {
        super("notes");
        this.note = null;
        this.noteId = null;
        this.noteUpdate = null;
    }

    protected generate_sql_insert(): string {
        return `INSERT INTO notes (title, content, is_archived, created_at) VALUES (?, ?, ?, ?)`;
    }

    // el AS es el apodo en como esta en la interfaz.
    protected get_atributes_list(): string {
        return "id, title, content, is_archived AS isArchived, created_at AS createdAt";
    }

    public async listAll(): Promise<Note[]> {
        const rows = await this.list<Note>();
        return rows.map((row) => ({
            ...row,
            isArchived: row.isArchived === null ? null : Boolean(row.isArchived), // Lo casteamos, esto pues esta entre 0 - 1.
            createdAt: new Date(row.createdAt)
        }));
    }

    public async insert_note(note: NoteInput): Promise<number> {
        this.note = note;
        return super.insert();
    }

    protected get_values_for_insert(): any[] {
        if (!this.note) {
            throw new Error("No se han configurado los datos de la nota para insertar");
        }
        return [
            this.note.title,
            this.note.content,
            this.note.isArchived ? 1 : 0,
            this.note.createdAt
        ];
    }

    // SQL para actualizar - SOLO campos de la tabla notes
    protected generate_sql_update(): string {
        if (!this.noteUpdate) {
            throw new Error("No hay datos para actualizar");
        }

        const fields: string[] = [];

        // Solo campos que existen en la tabla notes
        if (this.noteUpdate.title !== undefined) {
            fields.push("title = ?");
        }
        if (this.noteUpdate.content !== undefined) {
            fields.push("content = ?");
        }
        if (this.noteUpdate.isArchived !== undefined) {
            fields.push("is_archived = ?");
        }

        // Validamos que al menos un campo esté presente
        if (fields.length === 0 && this.noteUpdate.idcategory === undefined) {
            throw new Error("No hay campos para actualizar");
        }

        // Si no hay campos de notes pero sí hay idcategory, retornamos un SQL dummy
        if (fields.length === 0) {
            return `UPDATE notes SET title = title WHERE id = ?`; 
        }

        return `UPDATE notes SET ${fields.join(", ")} WHERE id = ?`;
    }

    protected get_values_for_update(): any[] {
        if (!this.noteUpdate) {
            throw new Error("No se han configurado los datos de la nota para actualizar");
        }
        if (this.noteId === null) {
            throw new Error("No se ha especificado el ID de la nota para actualizar");
        }

        const values: any[] = [];

        // Solo agregamos valores para campos que existen en la tabla notes
        if (this.noteUpdate.title !== undefined) {
            values.push(this.noteUpdate.title);
        }
        if (this.noteUpdate.content !== undefined) {
            values.push(this.noteUpdate.content);
        }
        if (this.noteUpdate.isArchived !== undefined) {
            values.push(this.noteUpdate.isArchived ? 1 : 0);
        }

        // El ID siempre va al final
        values.push(this.noteId);

        return values;
    }

    public async update_note(id: number, updates: NoteUpdate): Promise<number> {
        this.noteId = id;
        this.noteUpdate = updates;
        return super.update();
    }

    protected generate_sql_delete(): string {
        return `DELETE FROM notes WHERE id = ?`;
    }

    protected get_values_for_delete(): any[] {
        if (this.noteId === null) {
            throw new Error("No se ha especificado el ID de la nota para eliminar");
        }
        return [this.noteId];
    }

    public async delete_note(id: number): Promise<number> {
        this.noteId = id;
        return super.delete();
    }

    // Operaciones adicionales para INSERT
    protected async execute_additional_operations(insertedId: number): Promise<void> {
        if(!this.note || !this.note.idCategory){
            return;
        }
        const sql = 'INSERT INTO note_categories (note_id, category_id) VALUES (?, ?)';
        await this.execute_additional_sql(sql, [insertedId, this.note.idCategory]);
    }

    // Para manejar operaciones adicionales en el UPDATE.
    protected async execute_additional_update_operations(): Promise<void> {
        if (!this.noteUpdate || this.noteUpdate.idcategory === undefined || this.noteId === null) {
            return;
        }

        // Primero eliminamos las categorías existentes para esta nota
        const deleteSql = 'DELETE FROM note_categories WHERE note_id = ?';
        await this.execute_additional_sql(deleteSql, [this.noteId]); // Asi, reasignamos.

        // Luego insertamos la nueva categoría
        const insertSql = 'INSERT INTO note_categories (note_id, category_id) VALUES (?, ?)';
        await this.execute_additional_sql(insertSql, [this.noteId, this.noteUpdate.idcategory]);
    }
}
```

## backend/api.http

```text
GET http://localhost:1234/notes

### Creamos una nota.
POST http://localhost:1234/notes
Content-Type: application/json

{
  "title": "Mi primera nota de prueba",
  "content": "Este es el contenido detallado de mi nota",
  "isArchived": false,
  "idCategory": 3
}

### Actualizar una nota.
PUT http://localhost:1234/notes/2
Content-Type: application/json

{
  "title": "Título actualizado",
  "content": "Contenido modificado"
}

### Ahora eliminar.
DELETE http://localhost:1234/notes/2

### Ahora las categorias

### Listar todas las categorías
GET http://localhost:1234/categories

### Crear una nueva categoría
POST http://localhost:1234/categories
Content-Type: application/json

{
  "name": "Trabajo_2"
}


### Eliminar una categoría (reemplaza el 1 con el ID real de alguna categoría que exista)
DELETE http://localhost:1234/categories/2
```

## backend/package.json

```json
{
  "name": "backend",
  "version": "1.0.0",
  "description": "",
  "main": "DBManagerMain.ts",
  "scripts": {
    "start": "node --loader ts-node/esm app.ts"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "type": "module",
  "devDependencies": {
    "@types/cors": "^2.8.19",
    "@types/express": "^5.0.3",
    "@types/node": "^24.7.0",
    "ts-node": "^10.9.2",
    "typescript": "^5.9.3"
  },
  "dependencies": {
    "cors": "^2.8.5",
    "dotenv": "^17.2.3",
    "express": "5.1.0",
    "mysql2": "^3.15.1"
  }
}
```

## backend/DBManager/db/DAOImpl.ts

```typescript
import { PoolConnection, ResultSetHeader, RowDataPacket } from "mysql2/promise";
import { DBManager } from "../config/DBManager.js";

export abstract class DAOImpl {
    private connection: PoolConnection | null = null;
    protected table_name: string;

    constructor(table_name: string) {
        this.table_name = table_name;
    }

    protected async close_connection(): Promise<void> {
        if (this.connection) {
            this.connection.release()
            this.connection = null;
        }
    }

    protected async init_transaction(): Promise<void> {
        this.connection = await DBManager.getInstance().getConnection();
        await this.connection.beginTransaction();
    }

    protected async commit_transaction(): Promise<void> {
        if (this.connection) {
            await this.connection.commit();
        }
    }

    protected async rollback_transaction(): Promise<void> {
        if (this.connection) {
            await this.connection.rollback();
        }
    }

    protected async query_execute<T extends RowDataPacket>(
        sql: string,
        params?: any[],
    ): Promise<T[]> {
        if (!this.connection) {
            throw new Error("No active connection...");
        }
        const [rows] = await this.connection.query<T[]>(sql, params);
        return rows;
    }

    public async list<T extends RowDataPacket>(): Promise<T[]> {
        let results: T[] = [];
        try {
            this.connection = await DBManager.getInstance().getConnection();
            const sql = this.generate_sql_list();
            results = await this.query_execute<T>(sql);
        } catch (error) {
            console.error(error);
        } finally {
            try {
                await this.close_connection();
            } catch (closeError) {
                console.error(closeError);
            }
        }
        return results;
    }

    private generate_sql_list(): string {
        const columns = this.get_atributes_list();
        return `SELECT ${columns} FROM ${this.table_name}`;
    }

    protected abstract get_atributes_list(): string;
    protected abstract generate_sql_insert(): string;

    protected async modify_bd_executes(
        sql: string,
        params?: any[]
    ): Promise<ResultSetHeader> {
        if (!this.connection) {
            throw new Error("No hay conexion activa");
        }
        const [result] = await this.connection.query<ResultSetHeader>(sql, params);
        return result;
    }

    protected async execute_additional_sql(
        sql: string,
        params?: any[]
    ): Promise<number> {
        if (!this.connection) {
            throw new Error("No hay conexion activa");
        }
        const [result] = await this.connection.query<ResultSetHeader>(sql, params);
        return result.affectedRows;
    }

    public async insert(): Promise<number> {
        let insertedId = 0;
        try {
            await this.init_transaction();

            const sql = this.generate_sql_insert();
            const params = this.get_values_for_insert();

            const result = await this.modify_bd_executes(sql, params);
            insertedId = result.insertId ?? 0;

            await this.execute_additional_operations(insertedId);
            await this.commit_transaction();

        } catch (error) {
            try {
                await this.rollback_transaction();
            } catch (errorRollback) {
                console.error("Error al hacer el rollback: ", errorRollback);
            }
            console.error(error);
            throw error;
        } finally {
            try {
                await this.close_connection();
            } catch (error) {
                console.error("Error al cerrar la conexion: ", error);
            }
        }
        return insertedId;
    }

    protected abstract get_values_for_insert(): any[];
    protected abstract execute_additional_operations(insertedId: number): Promise<void>;

    // UPDATE modificado para soportar operaciones adicionales
    public async update(): Promise<number> {
        let result = 0;
        try {
            await this.init_transaction();

            const sql = this.generate_sql_update();
            const params = this.get_values_for_update();

            const writeResult = await this.modify_bd_executes(sql, params);
            result = writeResult.affectedRows;

            // Llamamos a las operaciones adicionales (para tablas intermedias)
            await this.execute_additional_update_operations();

            await this.commit_transaction();

        } catch (error) {
            try {
                await this.rollback_transaction();
            } catch (errorRollback) {
                console.error("Error al hacer el rollback: ", errorRollback);
            }
            console.error(error);
            throw error;
        } finally {
            try {
                await this.close_connection();
            } catch (error) {
                console.error("Error al cerrar la conexion: ", error);
            }
        }
        return result;
    }

    protected abstract generate_sql_update(): string;
    protected abstract get_values_for_update(): any[];
    
    // Método para operaciones adicionales en UPDATE (opcional, por defecto no hace nada)
    protected async execute_additional_update_operations(): Promise<void> {
        
    }

    public async delete(): Promise<number> {
        let result = 0;
        try {
            await this.init_transaction();

            const sql = this.generate_sql_delete();
            const params = this.get_values_for_delete();

            const writeResult = await this.modify_bd_executes(sql, params);
            result = writeResult.affectedRows;

            await this.commit_transaction();

        } catch (error) {
            try {
                await this.rollback_transaction();
            } catch (errorRollback) {
                console.error("Error al hacer el rollback: ", errorRollback);
            }
            console.error(error);
            throw error;
        } finally {
            try {
                await this.close_connection();
            } catch (error) {
                console.error("Error al cerrar la conexion: ", error);
            }
        }
        return result;
    }

    protected abstract generate_sql_delete(): string;
    protected abstract get_values_for_delete(): any[];
}
```

## backend/DBManager/config/DBManager.ts

```typescript
import { createPool, Pool, PoolConnection, ResultSetHeader, RowDataPacket } from "mysql2/promise";
import dotenv from "dotenv"
import process from "process"
import path from "path";

// cwd permite capturar el directorio donde se esta ejecutando Node.
const envPath = path.join(process.cwd(), "DBManager", "util", "mysql.env"); // Generamos la ruta donde se encuentra la env.

dotenv.config(
    { path: envPath }
) // Lo carga todo dentro del process.env rapidamente.


// Que use el patron Singleton
export class DBManager {
    private static instance: DBManager;
    private pool: Pool; // De mysql2/promise

    private constructor() {
        this.pool = createPool({
            host: process.env.DB_HOST,
            port: Number(process.env.DB_PORT),
            user: process.env.DB_USER,
            password: process.env.DB_PASSWORD,
            database: process.env.DB_NAME,
            connectionLimit: 10
        });
    }

    static getInstance(): DBManager {
        if (!this.instance) this.instance = new DBManager(); // Se crea la instancia
        return this.instance;
    }
    
    // Importante retornar
    getPool(): Pool {
        return this.pool;
    }

    async getConnection(): Promise<PoolConnection> {
        return this.pool.getConnection();
    }


}
```

## backend/DBManager/DBManagerMain.ts

```typescript
/* Este es un codigo que permite realizar tests de todo el backend. Fue generado con IA por lo que no se ha dado tanta manipulacion a este apartado */
import { NoteBO } from "../notesManagement/BO/NoteBO.js";
import { CategoryBO } from "../notesManagement/BO/CategoryBO.js";
import { DBManager } from "./config/DBManager.js";
import { Note } from "../notesManagement/DA/dao/NoteDAO.js";
import { Category } from "../notesManagement/DA/dao/CategoryDAO.js";

/**
 * Suite de pruebas completa para el sistema de notas y categorías
 * Verifica todas las operaciones CRUD y relaciones entre tablas
 */

// Colores para la consola
const colors = {
    reset: "\x1b[0m",
    green: "\x1b[32m",
    red: "\x1b[31m",
    yellow: "\x1b[33m",
    blue: "\x1b[36m",
    bold: "\x1b[1m"
};

// Utilidades para logging
const log = {
    success: (msg: string) => console.log(`${colors.green}✓ ${msg}${colors.reset}`),
    error: (msg: string) => console.log(`${colors.red}✗ ${msg}${colors.reset}`),
    info: (msg: string) => console.log(`${colors.blue}ℹ ${msg}${colors.reset}`),
    warning: (msg: string) => console.log(`${colors.yellow}⚠ ${msg}${colors.reset}`),
    section: (msg: string) => console.log(`\n${colors.bold}${colors.blue}=== ${msg} ===${colors.reset}\n`)
};

// Instancias de los Business Objects
const noteBO = new NoteBO();
const categoryBO = new CategoryBO();

// Variables para almacenar IDs de prueba
let testCategoryId1: number;
let testCategoryId2: number;
let testNoteId1: number;
let testNoteId2: number;

/**
 * Función auxiliar para verificar resultados
 */
function assert(condition: boolean, successMsg: string, errorMsg: string): void {
    if (condition) {
        log.success(successMsg);
    } else {
        log.error(errorMsg);
        throw new Error(errorMsg);
    }
}

/**
 * PASO 1: Verificar conexión a la base de datos
 */
async function test_database_connection(): Promise<void> {
    log.section("PASO 1: Verificando conexión a la base de datos");
    
    try {
        const dbManager = DBManager.getInstance();
        const pool = dbManager.getPool();
        
        assert(
            pool !== null && pool !== undefined,
            "Conexión a la base de datos establecida correctamente",
            "Error: No se pudo conectar a la base de datos"
        );
    } catch (error) {
        log.error(`Error de conexión: ${error}`);
        throw error;
    }
}

/**
 * PASO 2: Limpiar datos de prueba anteriores
 */
async function test_cleanup_previous_data(): Promise<void> {
    log.section("PASO 2: Identificando datos existentes");
    
    try {
        // Listar notas existentes
        const existingNotes = await noteBO.listNotes();
        log.info(`Se encontraron ${existingNotes.length} notas existentes`);
        
        // Listar categorías existentes
        const existingCategories = await categoryBO.list_categories();
        log.info(`Se encontraron ${existingCategories.length} categorías existentes`);
        
        log.success("Identificación completada");
    } catch (error) {
        log.warning(`Advertencia durante identificación: ${error}`);
    }
}

/**
 * PASO 3: Probar INSERT de categorías
 */
async function test_category_insert(): Promise<void> {
    log.section("PASO 3: Probando INSERT de categorías");
    
    try {
        // Usamos nombres únicos con timestamp para evitar duplicados
        const timestamp = Date.now();
        
        // Insertar primera categoría
        testCategoryId1 = await categoryBO.insert_category(`Test_Trabajo_${timestamp}`);
        assert(
            testCategoryId1 > 0,
            `Categoría 'Test_Trabajo_${timestamp}' insertada correctamente (ID: ${testCategoryId1})`,
            "Error: No se pudo insertar la primera categoría de prueba"
        );
        
        // Insertar segunda categoría
        testCategoryId2 = await categoryBO.insert_category(`Test_Personal_${timestamp}`);
        assert(
            testCategoryId2 > 0,
            `Categoría 'Test_Personal_${timestamp}' insertada correctamente (ID: ${testCategoryId2})`,
            "Error: No se pudo insertar la segunda categoría de prueba"
        );
        
        // Verificar que los IDs son diferentes
        assert(
            testCategoryId1 !== testCategoryId2,
            "Las categorías tienen IDs únicos",
            "Error: Las categorías tienen el mismo ID"
        );
    } catch (error) {
        log.error(`Error en inserción de categorías: ${error}`);
        throw error;
    }
}

/**
 * PASO 4: Probar LIST de categorías
 */
async function test_category_list(): Promise<void> {
    log.section("PASO 4: Probando LIST de categorías");
    
    try {
        const categories: Category[] = await categoryBO.list_categories();
        
        assert(
            categories.length >= 2,
            `Se listaron ${categories.length} categorías correctamente`,
            "Error: No se encontraron las categorías insertadas"
        );
        
        // Verificar que nuestras categorías de prueba están en la lista
        const testCategory1 = categories.find(cat => cat.id === testCategoryId1);
        const testCategory2 = categories.find(cat => cat.id === testCategoryId2);
        
        assert(
            testCategory1 !== undefined,
            `Categoría de prueba 1 (ID: ${testCategoryId1}) encontrada en el listado`,
            "Error: Primera categoría de prueba no encontrada"
        );
        
        assert(
            testCategory2 !== undefined,
            `Categoría de prueba 2 (ID: ${testCategoryId2}) encontrada en el listado`,
            "Error: Segunda categoría de prueba no encontrada"
        );
        
        log.info("Categorías encontradas:");
        categories.forEach(cat => {
            console.log(`  - ID: ${cat.id}, Nombre: ${cat.name}`);
        });
    } catch (error) {
        log.error(`Error al listar categorías: ${error}`);
        throw error;
    }
}

/**
 * PASO 5: Probar INSERT de notas con categorías
 */
async function test_note_insert(): Promise<void> {
    log.section("PASO 5: Probando INSERT de notas con categorías");
    
    try {
        // Insertar primera nota con categoría "Trabajo"
        testNoteId1 = await noteBO.insert_note(
            "Completar documentación",
            "Escribir la documentación técnica del proyecto",
            false,
            testCategoryId1  // idCategory
        );
        
        assert(
            testNoteId1 > 0,
            `Nota 'Completar documentación' insertada correctamente (ID: ${testNoteId1})`,
            "Error: No se pudo insertar la primera nota"
        );
        
        // Insertar segunda nota con categoría "Personal"
        testNoteId2 = await noteBO.insert_note(
            "Comprar despensa",
            "Ir al supermercado mañana por la tarde",
            false,
            testCategoryId2  // idCategory
        );
        
        assert(
            testNoteId2 > 0,
            `Nota 'Comprar despensa' insertada correctamente (ID: ${testNoteId2})`,
            "Error: No se pudo insertar la segunda nota"
        );
        
        // Verificar que los IDs son diferentes
        assert(
            testNoteId1 !== testNoteId2,
            "Las notas tienen IDs únicos",
            "Error: Las notas tienen el mismo ID"
        );
        
        log.success("Inserción de notas con categorías exitosa");
    } catch (error) {
        log.error(`Error en inserción de notas: ${error}`);
        throw error;
    }
}

/**
 * PASO 6: Probar LIST de notas
 */
async function test_note_list(): Promise<void> {
    log.section("PASO 6: Probando LIST de notas");
    
    try {
        const notes: Note[] = await noteBO.listNotes();
        
        assert(
            notes.length >= 2,
            `Se listaron ${notes.length} notas correctamente`,
            "Error: No se encontraron las notas insertadas"
        );
        
        // Verificar que nuestras notas de prueba están en la lista
        const note1 = notes.find(note => note.id === testNoteId1);
        const note2 = notes.find(note => note.id === testNoteId2);
        
        assert(
            note1 !== undefined && note1.title === "Completar documentación",
            "Primera nota encontrada en el listado",
            "Error: Primera nota no encontrada"
        );
        
        assert(
            note2 !== undefined && note2.title === "Comprar despensa",
            "Segunda nota encontrada en el listado",
            "Error: Segunda nota no encontrada"
        );
        
        log.info("Notas encontradas:");
        notes.forEach(note => {
            console.log(`  - ID: ${note.id}, Título: ${note.title}, Archivada: ${note.isArchived}`);
        });
    } catch (error) {
        log.error(`Error al listar notas: ${error}`);
        throw error;
    }
}

/**
 * PASO 7: Probar UPDATE parcial de notas (solo título)
 */
async function test_note_update_partial(): Promise<void> {
    log.section("PASO 7: Probando UPDATE parcial de notas");
    
    try {
        // Actualizar solo el título de la primera nota
        const result = await noteBO.update_note(testNoteId1, {
            title: "Completar documentación URGENTE"
        });
        
        assert(
            result === 1,
            "Título de la nota actualizado correctamente",
            "Error: No se pudo actualizar el título"
        );
        
        // Verificar que el cambio se aplicó
        const notes = await noteBO.listNotes();
        const updatedNote = notes.find(note => note.id === testNoteId1);
        
        assert(
            updatedNote?.title === "Completar documentación URGENTE",
            "El nuevo título se guardó correctamente",
            "Error: El título no se actualizó en la base de datos"
        );
        
        assert(
            updatedNote?.content === "Escribir la documentación técnica del proyecto",
            "El contenido se mantuvo sin cambios (actualización parcial funcionó)",
            "Error: El contenido cambió cuando no debería"
        );
        
        log.success("Actualización parcial funciona correctamente");
    } catch (error) {
        log.error(`Error en actualización parcial: ${error}`);
        throw error;
    }
}

/**
 * PASO 8: Probar UPDATE de múltiples campos
 */
async function test_note_update_multiple(): Promise<void> {
    log.section("PASO 8: Probando UPDATE de múltiples campos");
    
    try {
        // Actualizar título y contenido de la segunda nota
        const result = await noteBO.update_note(testNoteId2, {
            title: "Comprar despensa y medicinas",
            content: "Lista: leche, pan, huevos, aspirinas",
            isArchived: false
        });
        
        assert(
            result === 1,
            "Múltiples campos actualizados correctamente",
            "Error: No se pudieron actualizar múltiples campos"
        );
        
        // Verificar los cambios
        const notes = await noteBO.listNotes();
        const updatedNote = notes.find(note => note.id === testNoteId2);
        
        assert(
            updatedNote?.title === "Comprar despensa y medicinas",
            "Título actualizado correctamente",
            "Error: El título no se actualizó"
        );
        
        assert(
            updatedNote?.content === "Lista: leche, pan, huevos, aspirinas",
            "Contenido actualizado correctamente",
            "Error: El contenido no se actualizó"
        );
        
        log.success("Actualización de múltiples campos funciona correctamente");
    } catch (error) {
        log.error(`Error en actualización múltiple: ${error}`);
        throw error;
    }
}

/**
 * PASO 9: Probar UPDATE de categoría de una nota
 */
async function test_note_update_category(): Promise<void> {
    log.section("PASO 9: Probando UPDATE de categoría");
    
    try {
        // Cambiar la categoría de la primera nota
        const result = await noteBO.update_note(testNoteId1, {
            idcategory: testCategoryId2  // Nota: tu código usa 'idcategory' en minúscula
        });
        
        assert(
            result >= 0,
            "Categoría de la nota actualizada correctamente",
            "Error: No se pudo actualizar la categoría"
        );
        
        log.success("Actualización de categoría funciona correctamente");
        log.info(`Nota ${testNoteId1} ahora está en categoría ${testCategoryId2}`);
    } catch (error) {
        log.error(`Error al actualizar categoría: ${error}`);
        throw error;
    }
}

/**
 * PASO 10: Probar archivar/desarchivar notas
 */
async function test_note_archive(): Promise<void> {
    log.section("PASO 10: Probando archivar/desarchivar notas");
    
    try {
        // Archivar la primera nota
        let result = await noteBO.update_note(testNoteId1, {
            isArchived: true
        });
        
        assert(
            result === 1,
            "Nota archivada correctamente",
            "Error: No se pudo archivar la nota"
        );
        
        // Verificar que se archivó
        let notes = await noteBO.listNotes();
        let archivedNote = notes.find(note => note.id === testNoteId1);
        
        assert(
            archivedNote?.isArchived === true,
            "El estado de archivado se guardó correctamente",
            "Error: El estado de archivado no se actualizó"
        );
        
        // Desarchivar la nota
        result = await noteBO.update_note(testNoteId1, {
            isArchived: false
        });
        
        assert(
            result === 1,
            "Nota desarchivada correctamente",
            "Error: No se pudo desarchivar la nota"
        );
        
        // Verificar que se desarchivó
        notes = await noteBO.listNotes();
        archivedNote = notes.find(note => note.id === testNoteId1);
        
        assert(
            archivedNote?.isArchived === false,
            "El estado de archivado se actualizó correctamente",
            "Error: El estado de archivado no se desactivó"
        );
        
        log.success("Funcionalidad de archivar/desarchivar funciona correctamente");
    } catch (error) {
        log.error(`Error al archivar/desarchivar: ${error}`);
        throw error;
    }
}

/**
 * PASO 11: Probar DELETE de notas
 */
async function test_note_delete(): Promise<void> {
    log.section("PASO 11: Probando DELETE de notas");
    
    try {
        // Contar notas antes de eliminar
        const notesBeforeDelete = await noteBO.listNotes();
        const countBefore = notesBeforeDelete.length;
        
        // Eliminar la primera nota de prueba
        const result = await noteBO.delete_note(testNoteId1);
        
        assert(
            result === 1,
            `Nota ${testNoteId1} eliminada correctamente`,
            "Error: No se pudo eliminar la nota"
        );
        
        // Verificar que se eliminó
        const notesAfterDelete = await noteBO.listNotes();
        const countAfter = notesAfterDelete.length;
        
        assert(
            countAfter === countBefore - 1,
            "El conteo de notas disminuyó en 1",
            "Error: El conteo de notas no cambió"
        );
        
        const deletedNote = notesAfterDelete.find(note => note.id === testNoteId1);
        
        assert(
            deletedNote === undefined,
            "La nota eliminada ya no aparece en el listado",
            "Error: La nota eliminada aún aparece en el listado"
        );
        
        log.success("Eliminación de notas funciona correctamente");
    } catch (error) {
        log.error(`Error al eliminar nota: ${error}`);
        throw error;
    }
}

/**
 * PASO 12: Probar DELETE de categorías
 */
async function test_category_delete(): Promise<void> {
    log.section("PASO 12: Probando DELETE de categorías");
    
    try {
        // Primero eliminar la nota restante que usa esta categoría
        await noteBO.delete_note(testNoteId2);
        log.info("Nota asociada eliminada para permitir eliminación de categoría");
        
        // Contar categorías antes
        const categoriesBeforeDelete = await categoryBO.list_categories();
        const countBefore = categoriesBeforeDelete.length;
        
        // Eliminar la primera categoría de prueba
        const result1 = await categoryBO.delete_category(testCategoryId1);
        
        assert(
            result1 === 1,
            `Categoría ${testCategoryId1} eliminada correctamente`,
            "Error: No se pudo eliminar la primera categoría"
        );
        
        // Eliminar la segunda categoría de prueba
        const result2 = await categoryBO.delete_category(testCategoryId2);
        
        assert(
            result2 === 1,
            `Categoría ${testCategoryId2} eliminada correctamente`,
            "Error: No se pudo eliminar la segunda categoría"
        );
        
        // Verificar que se eliminaron
        const categoriesAfterDelete = await categoryBO.list_categories();
        const countAfter = categoriesAfterDelete.length;
        
        assert(
            countAfter === countBefore - 2,
            "El conteo de categorías disminuyó en 2",
            "Error: El conteo de categorías no cambió correctamente"
        );
        
        log.success("Eliminación de categorías funciona correctamente");
    } catch (error) {
        log.error(`Error al eliminar categorías: ${error}`);
        throw error;
    }
}

/**
 * Función principal que ejecuta todas las pruebas
 */
async function runAllTests(): Promise<void> {
    console.log(`${colors.bold}${colors.blue}`);
    console.log("╔════════════════════════════════════════════════════════════╗");
    console.log("║                                                            ║");
    console.log("║        SUITE DE PRUEBAS COMPLETA - SISTEMA DE NOTAS       ║");
    console.log("║                                                            ║");
    console.log("╚════════════════════════════════════════════════════════════╝");
    console.log(colors.reset);
    
    const startTime = Date.now();
    let testsPassed = 0;
    let testsFailed = 0;
    
    const tests = [
        { name: "Conexión a BD", fn: test_database_connection },
        { name: "Identificación de datos", fn: test_cleanup_previous_data },
        { name: "INSERT Categorías", fn: test_category_insert },
        { name: "LIST Categorías", fn: test_category_list },
        { name: "INSERT Notas", fn: test_note_insert },
        { name: "LIST Notas", fn: test_note_list },
        { name: "UPDATE Parcial", fn: test_note_update_partial },
        { name: "UPDATE Múltiple", fn: test_note_update_multiple },
        { name: "UPDATE Categoría", fn: test_note_update_category },
        { name: "Archivar/Desarchivar", fn: test_note_archive },
        { name: "DELETE Notas", fn: test_note_delete },
        { name: "DELETE Categorías", fn: test_category_delete }
    ];
    
    for (const test of tests) {
        try {
            await test.fn();
            testsPassed++;
        } catch (error) {
            testsFailed++;
            log.error(`Prueba fallida: ${test.name}`);
            console.error(error);
            break; // Detenemos si falla alguna prueba
        }
    }
    
    const endTime = Date.now();
    const duration = ((endTime - startTime) / 1000).toFixed(2);
    
    // Resumen final
    console.log(`\n${colors.bold}${colors.blue}╔════════════════════════════════════════════════════════════╗${colors.reset}`);
    console.log(`${colors.bold}${colors.blue}║                    RESUMEN DE PRUEBAS                      ║${colors.reset}`);
    console.log(`${colors.bold}${colors.blue}╚════════════════════════════════════════════════════════════╝${colors.reset}\n`);
    
    console.log(`  ${colors.green}Pruebas exitosas: ${testsPassed}${colors.reset}`);
    console.log(`  ${colors.red}Pruebas fallidas: ${testsFailed}${colors.reset}`);
    console.log(`  ${colors.blue}Tiempo total: ${duration}s${colors.reset}\n`);
    
    if (testsFailed === 0) {
        console.log(`${colors.bold}${colors.green}┌────────────────────────────────────────────────────────────┐${colors.reset}`);
        console.log(`${colors.bold}${colors.green}│                                                            │${colors.reset}`);
        console.log(`${colors.bold}${colors.green}│  ✓✓✓  TODAS LAS PRUEBAS PASARON EXITOSAMENTE  ✓✓✓        │${colors.reset}`);
        console.log(`${colors.bold}${colors.green}│                                                            │${colors.reset}`);
        console.log(`${colors.bold}${colors.green}│       El sistema está listo para conectarse a la API      │${colors.reset}`);
        console.log(`${colors.bold}${colors.green}│                                                            │${colors.reset}`);
        console.log(`${colors.bold}${colors.green}└────────────────────────────────────────────────────────────┘${colors.reset}\n`);
        process.exit(0);
    } else {
        console.log(`${colors.bold}${colors.red}┌────────────────────────────────────────────────────────────┐${colors.reset}`);
        console.log(`${colors.bold}${colors.red}│                                                            │${colors.reset}`);
        console.log(`${colors.bold}${colors.red}│  ✗✗✗  ALGUNAS PRUEBAS FALLARON  ✗✗✗                       │${colors.reset}`);
        console.log(`${colors.bold}${colors.red}│                                                            │${colors.reset}`);
        console.log(`${colors.bold}${colors.red}│     Por favor revisa los errores antes de continuar       │${colors.reset}`);
        console.log(`${colors.bold}${colors.red}│                                                            │${colors.reset}`);
        console.log(`${colors.bold}${colors.red}└────────────────────────────────────────────────────────────┘${colors.reset}\n`);
        process.exit(1);
    }
}

// Ejecutar todas las pruebas
runAllTests().catch((error) => {
    log.error(`Error crítico en las pruebas: ${error}`);
    process.exit(1);
});
```

## backend/app.ts

```typescript
import express, { json } from 'express' // require -> commonJS
import { categoriesRouter, notesRouter } from './API/routes/notesRoutes.js'
import cors from 'cors';
const app = express()

app.disable('x-powered-by') // Para que no muestre el header del express.

app.use(json())
app.use(cors()) // Middleware

// Usamos plural, representando coleccion de recursos.
app.use('/notes', notesRouter);
app.use('/categories', categoriesRouter);


const PORT = process.env.PORT ?? 1234

app.listen(PORT, () => {
    console.log(`server listening on port http://localhost:${PORT}`)
})
```

## setup.sh

```bash
#!/bin/bash

set -e  # Detener el script si hay algún error

echo "=========================================="
echo "Notes App - Setup Script"
echo "=========================================="
echo ""

# ============================================
# FUNCIONES AUXILIARES
# ============================================

# Función para comparar versiones (formato X.Y.Z)
version_compare() {
    local version1=$1
    local version2=$2
    
    # Convertir versiones a arrays
    IFS='.' read -ra VER1 <<< "$version1"
    IFS='.' read -ra VER2 <<< "$version2"
    
    # Comparar cada componente
    for i in {0..2}; do
        v1=${VER1[i]:-0}
        v2=${VER2[i]:-0}
        
        if [ $v1 -gt $v2 ]; then
            return 0
        elif [ $v1 -lt $v2 ]; then
            return 1
        fi
    done
    
    return 0
}

# ============================================
# VERIFICAR REQUISITOS
# ============================================
echo "Checking system requirements..."
echo ""

# Verificar Node.js
if ! command -v node &> /dev/null; then
    echo "ERROR: Node.js is not installed. Please install Node.js v22.14.0 or higher."
    exit 1
fi

NODE_VERSION=$(node -v | sed 's/v//')
REQUIRED_NODE_VERSION="22.14.0"

if ! version_compare "$NODE_VERSION" "$REQUIRED_NODE_VERSION"; then
    echo "WARNING: Node.js version $NODE_VERSION is lower than recommended v$REQUIRED_NODE_VERSION"
    echo "The application may not work correctly."
    echo ""
fi

echo "✓ Node.js found: v$NODE_VERSION"

# Verificar npm
if ! command -v npm &> /dev/null; then
    echo "ERROR: npm is not installed."
    exit 1
fi

NPM_VERSION=$(npm -v)
echo "✓ npm found: v$NPM_VERSION"

# Verificar MySQL
if ! command -v mysql &> /dev/null; then
    echo "ERROR: MySQL is not installed or not in PATH."
    echo "Please install MySQL v8.4.2 or higher and make sure it's running."
    exit 1
fi

echo "✓ MySQL found"
echo ""

# ============================================
# CONFIGURAR BASE DE DATOS
# ============================================
echo "Configuring MySQL database..."
echo ""
echo "IMPORTANT: This application requires MySQL root user WITHOUT password."
echo ""

# Configuración de MySQL
MYSQL_USER="root"

# Intentar conectar sin contraseña
echo "Attempting to connect to MySQL without password..."
if mysql -u "$MYSQL_USER" -e "SELECT 1;" &> /dev/null; then
    echo "✓ Connected to MySQL without password"
    MYSQL_PASSWORD=""
else
    # Si falla, pedir contraseña
    echo ""
    echo "MySQL requires a password for root user."
    read -sp "Enter MySQL root password: " MYSQL_PASSWORD
    echo ""
    
    # Verificar conexión con contraseña
    if ! mysql -u "$MYSQL_USER" -p"$MYSQL_PASSWORD" -e "SELECT 1;" &> /dev/null; then
        echo "ERROR: Unable to connect to MySQL. Please check your credentials."
        exit 1
    fi
    echo "✓ Connected to MySQL with password"
    echo ""
    echo "WARNING: Your backend will need to be configured to use the password."
    echo "         The setup will create the mysql.env file with DB_PASSWORD."
fi

# Crear la base de datos
echo "Creating database 'notes_app'..."
if [ -z "$MYSQL_PASSWORD" ]; then
    mysql -u "$MYSQL_USER" -e "CREATE DATABASE IF NOT EXISTS notes_app;"
else
    mysql -u "$MYSQL_USER" -p"$MYSQL_PASSWORD" -e "CREATE DATABASE IF NOT EXISTS notes_app;"
fi

if [ $? -ne 0 ]; then
    echo "ERROR: Failed to create database"
    exit 1
fi

echo "✓ Database created successfully"

# Ejecutar script de inicialización
echo "Running initialization script..."
if [ ! -f "backend/init.sql" ]; then
    echo "ERROR: File backend/init.sql not found"
    exit 1
fi

if [ -z "$MYSQL_PASSWORD" ]; then
    mysql -u "$MYSQL_USER" notes_app < backend/init.sql
else
    mysql -u "$MYSQL_USER" -p"$MYSQL_PASSWORD" notes_app < backend/init.sql
fi

if [ $? -ne 0 ]; then
    echo "ERROR: Failed to execute SQL script"
    exit 1
fi

echo "✓ Database initialized successfully"
echo ""

# ============================================
# CONFIGURAR BACKEND
# ============================================
echo "Configuring backend..."

# Crear directorio si no existe
mkdir -p backend/DBManager/util

cd backend

# Crear archivo mysql.env
if [ ! -f "DBManager/util/mysql.env" ]; then
    echo "Creating mysql.env file..."
    cat > DBManager/util/mysql.env << EOF
DB_HOST=localhost
DB_PORT=3306
DB_USER=root
DB_NAME=notes_app
EOF
    
    # Añadir contraseña si se proporcionó
    if [ -n "$MYSQL_PASSWORD" ]; then
        echo "DB_PASSWORD=$MYSQL_PASSWORD" >> DBManager/util/mysql.env
        echo "✓ mysql.env file created with password at backend/DBManager/util/"
        echo ""
        echo "WARNING: You need to modify backend/DBManager/DBManager.ts"
        echo "         to use process.env.DB_PASSWORD in the connection."
    else
        echo "✓ mysql.env file created at backend/DBManager/util/"
    fi
else
    echo "INFO: mysql.env file already exists, skipping creation"
fi

# Instalar dependencias
echo "Installing backend dependencies..."
npm install

if [ $? -ne 0 ]; then
    echo "ERROR: Failed to install backend dependencies"
    exit 1
fi

echo "✓ Backend dependencies installed"

cd ..
echo ""

# ============================================
# CONFIGURAR FRONTEND
# ============================================
echo "Configuring frontend..."

cd frontend/todo-app

# Crear archivo .env
if [ ! -f ".env" ]; then
    echo "Creating .env file..."
    cat > .env << EOF
VITE_API_URL=http://localhost:1234
EOF
    echo "✓ .env file created"
else
    echo "INFO: .env file already exists, skipping creation"
fi

# Instalar dependencias
echo "Installing frontend dependencies..."
npm install

if [ $? -ne 0 ]; then
    echo "ERROR: Failed to install frontend dependencies"
    exit 1
fi

echo "✓ Frontend dependencies installed"

cd ../..
echo ""

# ============================================
# FINALIZACIÓN
# ============================================
echo "=========================================="
echo "✓ Setup completed successfully!"
echo "=========================================="
echo ""
echo "To start the application:"
echo ""
echo "  Terminal 1 - Backend:"
echo "  $ cd backend"
echo "  $ npm start"
echo ""
echo "  Terminal 2 - Frontend:"
echo "  $ cd frontend/todo-app"
echo "  $ npm run dev"
echo ""
echo "The application will be available at:"
echo "  - Frontend: http://localhost:5173"
echo "  - Backend:  http://localhost:1234"
echo ""
echo "=========================================="
```

## frontend/todo-app/README.md

```markdown
# React + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) (or [oxc](https://oxc.rs) when used in [rolldown-vite](https://vite.dev/guide/rolldown)) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## React Compiler

The React Compiler is not enabled on this template because of its impact on dev & build performances. To add it, see [this documentation](https://react.dev/learn/react-compiler/installation).

## Expanding the ESLint configuration

If you are developing a production application, we recommend using TypeScript with type-aware lint rules enabled. Check out the [TS template](https://github.com/vitejs/vite/tree/main/packages/create-vite/template-react-ts) for information on how to integrate TypeScript and [`typescript-eslint`](https://typescript-eslint.io) in your project.
```

## frontend/todo-app/index.html

```html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>todo-app</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>
```

## frontend/todo-app/src/main.jsx

```text
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import App from './app/App'

createRoot(document.getElementById('root')).render(
  <StrictMode>
    <App />
  </StrictMode>,
)
```

## frontend/todo-app/src/app/store/store.js

```javascript
// Este es el store global de Redux.
import { configureStore } from "@reduxjs/toolkit";
import categoriesSlice from "../../features/tasks/store/categoriesSlice.js"
import tasksSlice from "../../features/tasks/store/tasksSlice.js"

const store = configureStore({
    reducer: {
        categories: categoriesSlice,
        tasks: tasksSlice
    }
})

export default store;
```

## frontend/todo-app/src/app/routes/index.jsx

```text
import { createBrowserRouter, createRoutesFromElements, Route } from "react-router-dom";
import { ArchivePage } from "../../features/tasks/pages/ArchivePage";
import { TasksPage } from "../../features/tasks/pages/TasksPage";
import { AppLayout } from "../layouts/AppLayout";


export const router = createBrowserRouter(createRoutesFromElements(
    <Route path="/" element={<AppLayout />} >
      <Route index element={<TasksPage />}></Route>
      <Route path="/archive" element={<ArchivePage />}></Route>
    </Route>
  ))
```

## frontend/todo-app/src/app/layouts/AppLayout.jsx

```text
import { Outlet } from "react-router-dom";
import { NavBar } from "../../features/tasks/components/NavBar";
import { Provider } from "react-redux";
import store from "../store/store";

export function AppLayout() {
    return (
        <>
            {/* Aqui empieza el NavBar */}
            <Provider store={store}>
                <NavBar />
                <main>
                    <h1>Todo App!</h1>
                    <Outlet />
                </main>
            </Provider>
        </>
    )
}
```

## frontend/todo-app/src/app/App.jsx

```text
import 'bootstrap/dist/css/bootstrap.min.css' // CSS de Boostrap.

import { RouterProvider } from 'react-router-dom'
import { router } from './routes'



function App() {

  return (
    <div className='container'>
      <RouterProvider router={router} />
    </div>
  )
}

export default App
```

## frontend/todo-app/src/features/tasks/store/categoriesSlice.js

```javascript
import { createSlice, createAsyncThunk } from "@reduxjs/toolkit";
import { categoriesApi } from "../api/categoriesApi.js"; 

const initialState = {
    categories: [],
    loading: false,
    error: null
}


export const fetchCategories = createAsyncThunk(
    'categories/fetchCategories',
    async (_, { rejectWithValue }) => {
        try {
            const data = await categoriesApi.list_categories();
            if (data === undefined) {
                return rejectWithValue('Error al cargar las categorías');
            }
            return data;
        } catch (error) {
            console.log(error);
            return rejectWithValue(error.message || 'Error desconocido');
        }
    }
)

export const createCategory = createAsyncThunk(
    'categories/createCategory',
    async (categoryData, { dispatch, rejectWithValue }) => {
        try {
            const id = await categoriesApi.create_category(categoryData);
            if (id === undefined) {
                return rejectWithValue('Error al crear la categoría');
            }
            dispatch(fetchCategories()); // Para actualizar la lista
            return id;
        } catch (error) {
            console.log(error);
            return rejectWithValue(error.message || 'Error desconocido');
        }
    }
)

export const deleteCategory = createAsyncThunk(
    'categories/deleteCategory',
    async (id, { rejectWithValue }) => {
        try {
            await categoriesApi.delete_category(id);
            return id;
        } catch (error) {
            console.log(error);
            return rejectWithValue(error.message || 'Error desconocido');
        }
    }
)

// Slice
const categoriesSlice = createSlice({
  name: 'categories',
  initialState,
  reducers: {
    clearError: (state) => {
      state.error = null;
    },
  },
  extraReducers: (builder) => {
    builder
      // fetchCategories
      .addCase(fetchCategories.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchCategories.fulfilled, (state, action) => {
        state.loading = false;
        state.categories = action.payload;
      })
      .addCase(fetchCategories.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload;
      })

      // createCategory
      .addCase(createCategory.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(createCategory.fulfilled, (state) => {
        state.loading = false;
      })
      .addCase(createCategory.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload;
      })

      // deleteCategory
      .addCase(deleteCategory.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(deleteCategory.fulfilled, (state, action) => {
        state.loading = false;
        state.categories = state.categories.filter(
          (category) => category.id !== action.payload
        );
      })
      .addCase(deleteCategory.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload;
      });
  },
});

export const { clearError } = categoriesSlice.actions;
export default categoriesSlice.reducer;
```

## frontend/todo-app/src/features/tasks/store/tasksSlice.js

```javascript
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import { tasksApi } from '../api/tasksApi.js';

const initialState = {
  tasks: [],
  loading: false,
  error: null,
  selectedTask: null,
  filter: null, // { type: 'archived' | 'category', value?: categoryId, label?: categoryName }. Asi sera el modelo.
  // Si es NULL, el user ve todas las tareas.
  // Si es archived, el user ve solo las archivadas.
  //  El otro ya es filtro por categoria.
};

export const fetchTasks = createAsyncThunk(
  'tasks/fetchTasks',
  async (_, { rejectWithValue }) => {
    try {
      const data = await tasksApi.list_tasks();
      if (data === undefined) {
        return rejectWithValue('Error al cargar las tareas');
      }
      return data;
    } catch (error) {
      console.log(error);
      return rejectWithValue(error.message || 'Error desconocido');
    }
  }
);

export const createTask = createAsyncThunk(
  'tasks/createTask',
  async (taskData, { dispatch, rejectWithValue }) => {
    try {
      const id = await tasksApi.create_task(taskData);
      if (id === undefined) {
        return rejectWithValue('Error al crear la tarea');
      }
      dispatch(fetchTasks());
      return id;
    } catch (error) {
      console.log(error);
      return rejectWithValue(error.message || 'Error desconocido');
    }
  }
);

export const updateTask = createAsyncThunk(
  'tasks/updateTask',
  async ({ id, updates }, { rejectWithValue }) => {
    try {
      await tasksApi.update_task(id, updates);
      return { id, updates };
    } catch (error) {
      console.log(error);
      return rejectWithValue(error.message || 'Error desconocido');
    }
  }
);

export const deleteTask = createAsyncThunk(
  'tasks/deleteTask',
  async (id, { rejectWithValue }) => {
    try {
      await tasksApi.delete_task(id);
      return id;
    } catch (error) {
      console.log(error);
      return rejectWithValue(error.message || 'Error desconocido');
    }
  }
);

const tasksSlice = createSlice({
  name: 'tasks',
  initialState,
  reducers: {
    setSelectedTask: (state, action) => {
      state.selectedTask = action.payload;
    },
    clearError: (state) => {
      state.error = null;
    },
    setFilter: (state, action) => {
      state.filter = action.payload;
    },
    clearFilter: (state) => {
      state.filter = null;
    },
  },
  extraReducers: (builder) => {
    builder
      .addCase(fetchTasks.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchTasks.fulfilled, (state, action) => {
        state.loading = false;
        state.tasks = action.payload;
      })
      .addCase(fetchTasks.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload;
      })
      .addCase(createTask.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(createTask.fulfilled, (state) => {
        state.loading = false;
      })
      .addCase(createTask.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload;
      })
      .addCase(updateTask.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(updateTask.fulfilled, (state, action) => {
        state.loading = false;
        const { id, updates } = action.payload;
        const taskIndex = state.tasks.findIndex((task) => task.id === id);
        if (taskIndex !== -1) {
          state.tasks[taskIndex] = { ...state.tasks[taskIndex], ...updates };
        }
        if (state.selectedTask?.id === id) {
          state.selectedTask = { ...state.selectedTask, ...updates };
        }
      })
      .addCase(updateTask.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload;
      })
      .addCase(deleteTask.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(deleteTask.fulfilled, (state, action) => {
        state.loading = false;
        state.tasks = state.tasks.filter((task) => task.id !== action.payload);
        if (state.selectedTask?.id === action.payload) {
          state.selectedTask = null;
        }
      })
      .addCase(deleteTask.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload;
      });
  },
});

export const { setSelectedTask, clearError, setFilter, clearFilter } = tasksSlice.actions;
export default tasksSlice.reducer;
```

## frontend/todo-app/src/features/tasks/api/tasksApi.js

```javascript
import axios from "axios";



const TASKS_URL = "http://localhost:1234/notes";

async function list_tasks() {
    try {
        const response = await axios.get(TASKS_URL);
        return response.data.data; // Enl a API, se manda asi.
    } catch (error) {
        console.log(e)
        return undefined;
    }
}

// Asi se tiene que mandar.
/* {
  "title": "Mi primera nota de prueba",
  "content": "Este es el contenido detallado de mi nota",
  "isArchived": false,
  "idCategory": 3
} */

async function create_task(taskData) {
    // taskData ya debe venir con el formato correcto:
    // { title, content, isArchived, idCategory }
    try {
        const response = await axios.post(
            TASKS_URL,
            taskData,  // Enviar directamente el objeto
            {
                headers: {
                    'Content-Type': 'application/json'
                }
            }
        );
        return response.data.data.id;
    } catch (error) {
        console.log(error);
        return undefined;
    }
}

// Ahora pasamos con actualizar.
/* 
export interface NoteUpdate {
    title?: string;        
    content?: string;
    isArchived?: boolean;
    idcategory?: number;
} */
async function update_task(id, updates) {
    try {
        const response = await axios.put(
            `${TASKS_URL}/${id}`, 
            updates,
            {
                headers: {
                    'Content-Type': 'application/json'
                },
                timeout: 10000
            }
        );
        return response.data;
    } catch (error) {
        console.log(error);
        return undefined;
    }
}

// Ahora el delete
async function delete_task(task_id){ // Solo se le pasa 1 parametro.
    // Va a devolver 1 id.
    const payload = task_id;
    try {
        const response = await axios.delete(
            TASKS_URL + "/" + payload.toString(),
            {
                headers: {
                    'Content-Type': 'application/json'
                },
                timeout: 10000
            }
        )
        return response.data.data;

    } catch (error) {
        console.log(error);
        return undefined;
    }
}

export const tasksApi = {
    list_tasks,
    create_task,
    update_task,
    delete_task
};
```

## frontend/todo-app/src/features/tasks/api/categoriesApi.js

```javascript
import axios from "axios";


const CATEGORIES_URL = "http://localhost:1234/categories";

async function list_categories() {
    try {
        const response = await axios.get(CATEGORIES_URL);
        return response.data.data; // Enl a API, se manda asi.
    } catch (error) {
        console.log(e)
        return undefined;
    }
}

// Asi se tiene que mandar.
/* {
  {
    "name": "Trabajo_2"
    }
} */

// Se pasa el category y el id de la categoria asignada.
async function create_category(category) {
    // Esta parte reestructurarlo de tal manera que quede igual que los POST.
    const payload = category;

    try {
        const response = await axios.post(
            CATEGORIES_URL,
            payload,
            {
                headers: {
                    'Content-Type': 'application/json'
                }
            }
        );
        return response.data.data.id;
    } catch (error) {
        console.log(error);
        return undefined;
    }

}


// Ahora el delete
async function delete_category(category_id) {
    try {
        const response = await axios.delete(
            `${CATEGORIES_URL}/${category_id}`,
            {
                headers: {
                    'Content-Type': 'application/json'
                },
                timeout: 10000
            }
        );
        return response.data;
    } catch (error) {
        console.log(error);
        return undefined;
    }
}

export const categoriesApi = {
    list_categories,
    create_category,
    delete_category
};
```

## frontend/todo-app/src/features/tasks/pages/ArchivePage.jsx

```text
export function ArchivePage(){
    return (
        <>
            <h1>Archive Page</h1>
        </>
    )
}
```

## frontend/todo-app/src/features/tasks/pages/TasksPage.jsx

```text
import { AddTaskForm } from "../components/AddTaskForm";
import { TaskList } from "../components/TaskList";

export function TasksPage() {


    return (
        <>
            <div>
                <AddTaskForm />
                <TaskList />
            </div>

        </>
    )
}
```

## frontend/todo-app/src/features/tasks/components/NavBar.jsx

```text
import { useState, useEffect } from "react";
import { Nav, NavDropdown } from "react-bootstrap";
import { useDispatch, useSelector } from "react-redux";
import { fetchCategories } from "../store/categoriesSlice";
import { setFilter, clearFilter } from "../store/tasksSlice";
import { AddCategoryModal } from "./AddCategoryModal";

export function NavBar() {
    const dispatch = useDispatch();
    const { categories } = useSelector(state => state.categories);
    const [showAddCategory, setShowAddCategory] = useState(false);

    useEffect(() => {
        dispatch(fetchCategories());
    }, []);

    const handleArchivedClick = () => {
        dispatch(setFilter({ type: 'archived' }));
    };

    const handleCategoryClick = (categoryId, categoryName) => {
        dispatch(setFilter({ type: 'category', value: categoryId, label: categoryName }));
    };

    const handleAllClick = () => {
        dispatch(clearFilter());
    };

    return (
        <>
            <Nav variant="pills" activeKey="1">
                <Nav.Item>
                    <Nav.Link eventKey="1" onClick={handleAllClick}>
                        All Tasks
                    </Nav.Link>
                </Nav.Item>
                <Nav.Item>
                    <Nav.Link eventKey="2" onClick={handleArchivedClick}>
                        Archived
                    </Nav.Link>
                </Nav.Item>
                <NavDropdown title="Categories" id="nav-dropdown">
                    {categories.map(category => (
                        <NavDropdown.Item 
                            key={category.id}
                            onClick={() => handleCategoryClick(category.id, category.name)}
                        >
                            {category.name}
                        </NavDropdown.Item>
                    ))}
                    <NavDropdown.Divider />
                    <NavDropdown.Item onClick={() => setShowAddCategory(true)}>
                        + Add category
                    </NavDropdown.Item>
                </NavDropdown>
            </Nav>

            <AddCategoryModal 
                show={showAddCategory} 
                handleClose={() => setShowAddCategory(false)} 
            />
        </>
    );
}
```

## frontend/todo-app/src/features/tasks/components/TaskList.jsx

```text
import { useState, useEffect } from "react";
import { useDispatch, useSelector } from "react-redux"
import { fetchTasks, deleteTask, updateTask, clearFilter } from "../store/tasksSlice";
import { fetchCategories } from "../store/categoriesSlice";
import Badge from "react-bootstrap/Badge";
import { Button, Card, ListGroup, Stack, Alert, ButtonGroup } from "react-bootstrap";
import { EditTaskModal } from "./EditTaskModal";

export function TaskList() {
    const dispatch = useDispatch();
    const [showEditModal, setShowEditModal] = useState(false); // Para mostrar modal del edit por tarea.
    const [selectedTask, setSelectedTask] = useState(null); // Esto para luego mostrar el task y editarlo.
    
    const { tasks, loading: tasksLoading, error: tasksError, filter } = useSelector(state => state.tasks);
    const { categories, loading: categoriesLoading } = useSelector(state => state.categories);

    useEffect(() => {
        dispatch(fetchTasks());
        dispatch(fetchCategories());
    }, []); // Usar ahi dispatch por EsLint. Es la misma funcionalidad.

    // Esto para buscar mas rapido las categorias.
    const categoryMap = new Map();
    categories.forEach(cat => {
        categoryMap.set(cat.id, cat.name);
    });

    // Se van a listar los tasks con su filter respectivo.
    // Si es true, se incluye en el array del filteredTasks
    const filteredTasks = tasks.filter(task => {
        if (!filter) return true;

        if (filter.type === 'archived') {
            return task.isArchived === true;
        }

        if (filter.type === 'category') {
            return task.categoryId === filter.value;
        }

        return true;
    });

    // Un mini-modal que indica si se desea eliminar el task.
    const handleDelete = (taskId) => {
        if (window.confirm('Are you sure you want to delete this task?')) {
            dispatch(deleteTask(taskId));
        }
    };

    // Para mostrar el modal del edit.
    const handleEdit = (task) => {
        setSelectedTask(task);
        setShowEditModal(true);
    };

    // El updateTask es asincronico. Proviene del AsyncThunk
    const handleToggleArchive = async (task) => {
        // Recordemos que en el update
        await dispatch(updateTask({ 
            id: task.id, 
            updates: { isArchived: !task.isArchived } 
        }));
        // Recargar para reflejar el cambio
        dispatch(fetchTasks());
    };

    // Asi se muestra si esta cargando o no. Provienen del ReduxStore
    if (tasksLoading || categoriesLoading) {
        return <Alert variant="info">Loading...</Alert>;
    }

    if (tasksError) {
        return <Alert variant="danger">Error: {tasksError}</Alert>;
    }

    // En caso no haya informacion en la base de datos.
    if (!tasks || !Array.isArray(tasks)) {
        return <Alert variant="warning">No tasks available</Alert>;
    }

    // Esto en caso no haya tasks con el filtro que se ha decidid.
    if (filteredTasks.length === 0) {
        return (
            <Alert variant="info">
                {filter 
                    ? `No tasks ${filter.type === 'archived' ? 'archived' : `in category "${filter.label}"`}`
                    : 'No tasks available'
                }
            </Alert>
        );
    }

    // Los cards van a tener el nombre de la categoria.
    // El backend no permite que un task sea ingresado sin su categoria, por lo que esto es solo por seguridad.
    const cards = filteredTasks.map(task => {
        const categoryName = categoryMap.get(task.categoryId);

        return (
            <ListGroup.Item key={task.id}>
                <Card>
                    <Card.Body>
                        <Card.Title>{task.title}</Card.Title>
                        <Card.Text>{task.content}</Card.Text>
                        <Stack direction="horizontal" gap={2} className="mb-3">
                            <Badge bg="info">Category: {categoryName}</Badge>
                            {task.isArchived && <Badge bg="secondary">Archived</Badge>}
                        </Stack>

                        <ButtonGroup>
                            <Button 
                                variant="primary" 
                                size="sm"
                                onClick={() => handleEdit(task)}
                            >
                                Edit
                            </Button>
                            <Button 
                                variant={task.isArchived ? "success" : "warning"}
                                size="sm"
                                onClick={() => handleToggleArchive(task)}
                            >
                                {task.isArchived ? "Unarchive" : "Archive"}
                            </Button>
                            <Button 
                                variant="danger" 
                                size="sm"
                                onClick={() => handleDelete(task.id)}
                            >
                                Delete
                            </Button>
                        </ButtonGroup>
                    </Card.Body>
                </Card>
            </ListGroup.Item>
        )
    });

    return (
        <>
            {filter && (
                <Alert variant="primary" dismissible onClose={() => dispatch(clearFilter())}>
                    <strong>Active filter:</strong> {filter.type === 'archived' ? 'Archived tasks' : `Category: ${filter.label}`}
                </Alert>
            )}
            <ListGroup>
                {cards}
            </ListGroup>
            {/* Aqui se maneja con un true or false para que muestre ese taskModal */}
            <EditTaskModal 
                show={showEditModal}
                handleClose={() => setShowEditModal(false)}
                task={selectedTask}
            />
        </>
    )
}
```

## frontend/todo-app/src/features/tasks/components/TaskComponent.jsx

```text

```

## frontend/todo-app/src/features/tasks/components/AddCategoryModal.jsx

```text
import { useState } from "react";
import { Modal, Button, Form } from "react-bootstrap";
import { useDispatch } from "react-redux";
import { createCategory } from "../store/categoriesSlice";

// Del props.
export function AddCategoryModal({ show, handleClose }) {
    const dispatch = useDispatch();
    const [categoryName, setCategoryName] = useState(""); // Lo mantenemos en la pagina para luego insertarlo.

    const handleSubmit = (e) => {
        e.preventDefault(); 
        
        if (categoryName.trim()) { // Limpiamos 
            dispatch(createCategory({ name: categoryName }));
            setCategoryName("");
            handleClose();
        }
    };

    const handleModalClose = () => {
        setCategoryName(""); // Limpiamos.
        handleClose(); // Proviene del prop.
    };

    return (
        <Modal show={show} onHide={handleModalClose}>
            <Modal.Header closeButton>
                <Modal.Title>Add New Category</Modal.Title>
            </Modal.Header>
            <Modal.Body>
                <Form onSubmit={handleSubmit}>
                    <Form.Group className="mb-3">
                        <Form.Label>Category Name</Form.Label>
                        <Form.Control
                            type="text"
                            placeholder="E.g.: Personal, Work..."
                            value={categoryName}
                            onChange={(e) => setCategoryName(e.target.value)}
                            required
                        />
                    </Form.Group>

                    <div className="d-flex justify-content-end gap-2">
                        <Button variant="secondary" onClick={handleModalClose}>
                            Cancel
                        </Button>
                        <Button variant="primary" type="submit">
                            Add
                        </Button>
                    </div>
                </Form>
            </Modal.Body>
        </Modal>
    );
}
```

## frontend/todo-app/src/features/tasks/components/AddTaskForm.jsx

```text
import { useState } from 'react';
import Button from 'react-bootstrap/Button';
import Form from 'react-bootstrap/Form';
import { Modal } from 'react-bootstrap';
import { useDispatch, useSelector } from 'react-redux';
import { createTask } from '../store/tasksSlice';

export function AddTaskForm() {
  const dispatch = useDispatch();
  const { categories } = useSelector(state => state.categories);
  
  const [showModal, setShowModal] = useState(false);
  const [formData, setFormData] = useState({
    title: '',
    content: '',
    isArchived: false,
    idCategory: ''
  });

  const handleOpen = () => setShowModal(true);
  const handleClose = () => {
    setShowModal(false);
    // Limpiamos
    setFormData({
      title: '',
      content: '',
      isArchived: false,
      idCategory: ''
    });
  };

  const handleChange = (e) => {
    const { name, value, type, checked } = e.target; // Proveniente del form.
    // Usamos la forma funcional, por React.
    // "name" es el nombre de la propiedad. Asi podemos mandar info dependiendo del campo elegido.
    setFormData(prev => ({
      ...prev,
      [name]: type === 'checkbox' ? checked : value
    }));
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    
    
    const taskData = {
      ...formData,
      idCategory: parseInt(formData.idCategory)
    };

    dispatch(createTask(taskData));
    handleClose();
  };

  return (
    <>
      <div className="d-grid gap-2">
        <Button variant="primary" size="lg" onClick={handleOpen}>
          Create 
        </Button>
      </div>

      <Modal show={showModal} onHide={handleClose}>
        <Modal.Header closeButton>
          <Modal.Title>Create New Task</Modal.Title>
        </Modal.Header>
        <Modal.Body>
          <Form onSubmit={handleSubmit}>
            <Form.Group className="mb-3">
              <Form.Label>Title</Form.Label>
              <Form.Control
                type="text"
                name="title"
                placeholder="Enter the title"
                value={formData.title}
                onChange={handleChange}
                required
              />
            </Form.Group>

            <Form.Group className="mb-3">
              <Form.Label>Content</Form.Label>
              <Form.Control
                as="textarea"
                rows={3}
                name="content"
                placeholder="Describe the task..."
                value={formData.content}
                onChange={handleChange}
                required
              />
            </Form.Group>

            <Form.Group className="mb-3">
              <Form.Label>Category</Form.Label>
              <Form.Select
                name="idCategory"
                value={formData.idCategory}
                onChange={handleChange}
                required
              >
                <option value="">Select a category</option>
                {categories.map(cat => (
                  <option key={cat.id} value={cat.id}>
                    {cat.name}
                  </option>
                ))}
              </Form.Select>
            </Form.Group>

            <Form.Group className="mb-3">
              <Form.Check
                type="checkbox"
                name="isArchived"
                label="Mark as archived"
                checked={formData.isArchived}
                onChange={handleChange}
              />
            </Form.Group>

            <div className="d-flex justify-content-end gap-2">
              <Button variant="secondary" onClick={handleClose}>
                Cancel
              </Button>
              <Button variant="primary" type="submit">
                Create Task
              </Button>
            </div>
          </Form>
        </Modal.Body>
      </Modal>
    </>
  );
}
```

## frontend/todo-app/src/features/tasks/components/EditTaskModal.jsx

```text
import { useState, useEffect } from "react";
import { Modal, Button, Form } from "react-bootstrap";
import { useDispatch, useSelector } from "react-redux";
import { updateTask, fetchTasks } from "../store/tasksSlice";

// Mandamos el task seleccionado.
export function EditTaskModal({ show, handleClose, task }) {
    const dispatch = useDispatch();
    const { categories } = useSelector(state => state.categories);

    // Los campos del forms se mantendran con el useState.
    const [formData, setFormData] = useState({
        title: "",
        content: "",
        idcategory: ""
    });

    useEffect(() => {
        if (task && show) {
            setFormData({
                title: task.title || "",
                content: task.content || "",
                idcategory: task.categoryId || ""
            });
        }
    }, [task, show]); // Solo actua si el task cambia o el show.

    
    const handleChange = (e) => {
        const { name, value } = e.target;
        setFormData(prev => ({
            ...prev,
            [name]: value
        }));
    };

    const handleSubmit = async (e) => {
        e.preventDefault();
        
        const updates = {};
        if (formData.title !== task.title) updates.title = formData.title;
        if (formData.content !== task.content) updates.content = formData.content;
        if (formData.idcategory && parseInt(formData.idcategory) !== task.categoryId) {
            updates.idcategory = parseInt(formData.idcategory);
        }

        if (Object.keys(updates).length > 0) {
            await dispatch(updateTask({ id: task.id, updates }));
        }

        handleClose();
        
        // Recargar después de cerrar el modal
        setTimeout(() => {
            dispatch(fetchTasks());
        }, 100);
    };

    return (
        <Modal show={show} onHide={handleClose}>
            <Modal.Header closeButton>
                <Modal.Title>Edit Task</Modal.Title>
            </Modal.Header>
            <Modal.Body>
                <Form onSubmit={handleSubmit}>
                    <Form.Group className="mb-3">
                        <Form.Label>Title</Form.Label>
                        <Form.Control
                            type="text"
                            name="title"
                            value={formData.title}
                            onChange={handleChange}
                            required
                        />
                    </Form.Group>

                    <Form.Group className="mb-3">
                        <Form.Label>Content</Form.Label>
                        <Form.Control
                            as="textarea"
                            rows={3}
                            name="content"
                            value={formData.content}
                            onChange={handleChange}
                            required
                        />
                    </Form.Group>

                    <Form.Group className="mb-3">
                        <Form.Label>Category</Form.Label>
                        <Form.Select
                            name="idcategory"
                            value={formData.idcategory}
                            onChange={handleChange}
                            required
                        >
                            <option value="">Select a category</option>
                            {categories.map(cat => (
                                <option key={cat.id} value={cat.id}>
                                    {cat.name}
                                </option>
                            ))}
                        </Form.Select>
                    </Form.Group>

                    <div className="d-flex justify-content-end gap-2">
                        <Button variant="secondary" onClick={handleClose}>
                            Cancel
                        </Button>
                        <Button variant="primary" type="submit">
                            Save Changes
                        </Button>
                    </div>
                </Form>
            </Modal.Body>
        </Modal>
    );
}
```

## frontend/todo-app/vite.config.js

```javascript
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
})
```

## frontend/todo-app/.gitignore

```text
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
```

## frontend/todo-app/eslint.config.js

```javascript
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import { defineConfig, globalIgnores } from 'eslint/config'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{js,jsx}'],
    extends: [
      js.configs.recommended,
      reactHooks.configs['recommended-latest'],
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    rules: {
      'no-unused-vars': ['error', { varsIgnorePattern: '^[A-Z_]' }],
    },
  },
])
```

## frontend/todo-app/package.json

```json
{
  "name": "todo-app",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@reduxjs/toolkit": "^2.9.0",
    "axios": "^1.12.2",
    "bootstrap": "^5.3.8",
    "react": "^19.1.1",
    "react-bootstrap": "^2.10.10",
    "react-dom": "^19.1.1",
    "react-redux": "^9.2.0",
    "react-router-dom": "^7.9.3"
  },
  "devDependencies": {
    "@eslint/js": "^9.36.0",
    "@types/react": "^19.1.16",
    "@types/react-dom": "^19.1.9",
    "@vitejs/plugin-react": "^5.0.4",
    "eslint": "^9.36.0",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.22",
    "globals": "^16.4.0",
    "vite": "^7.1.7"
  }
}
```

## README.md

````markdown
# Notes App - Task Manager

Full-stack application for managing notes and tasks with categorization.

## System Requirements

### Required Software

| Software | Required Version | Check Version |
|----------|-----------------|---------------|
| Node.js  | v22.14.0 or higher | `node -v` |
| npm      | v11.5.2 or higher | `npm -v` |
| MySQL    | v8.4.2 or higher | `mysql --version` |

### Operating System

- Linux (Ubuntu, Debian, etc.)
- macOS
- Windows (requires Git Bash or WSL)


## Quick Installation

### 1: Automatic Script

```bash
# 1. Clone the repository
git clone <repository-url>
cd <repository-name>

# 2. Give execution permissions to the script
chmod +x setup.sh

# 3. Run the installation script
./setup.sh
```

The script automatically:
- Verifies MySQL and runs
- Creates the 'notes_app' database
- Executes the SQL initialization script
- Installs all dependencies
- Creates necessary configuration files


## Running the Application

### Start Backend

```bash
cd backend
npm start
```

Backend will be running at: **http://localhost:1234**

### Start Frontend

```bash
cd frontend/todo-app
npm run dev
```

Frontend will be running at: **http://localhost:5173**

**Important:** Both services must be running simultaneously in separate terminals.

## Project Structure

```
project/
├── backend/
│   ├── DBManager/
│   │   └── util/
│   │       └── mysql.env     # Database configuration (not in git)
│   ├── init.sql              # DB initialization script
│   ├── app.ts                # Server entry point
│   └── package.json          # Backend dependencies
├── frontend/
│   └── todo-app/
│       ├── .env              # Environment variables (not in git)
│       ├── package.json      # Frontend dependencies
│       └── src/
│           ├── components/   # React components
│           ├── store/        # Redux store
│           └── api/          # API client
├── setup.sh                  # Automatic installation script
├── .gitignore                # Git ignore rules
└── README.md                 # This file
```

## Tech Stack

### Backend

- **Runtime:** Node.js v22.14.0
- **Framework:** Express v5.1.0
- **Language:** TypeScript v5.9.3
- **Database:** MySQL v8.4.2
- **MySQL Client:** mysql2 v3.15.1
- **Loader:** ts-node v10.9.2

### Frontend

- **Framework:** React v19.1.1
- **Build Tool:** Vite v7.1.7
- **State Management:** Redux Toolkit v2.9.0
- **HTTP Client:** Axios v1.12.2
- **UI Framework:** React Bootstrap v2.10.10
- **Router:** React Router DOM v7.9.3

## Database

### Database Name

`notes_app`

### Main Tables

- **notes** - Stores notes/tasks
- **categories** - Available categories
- **note_categories** - 1:1 relationship between notes and categories

### Sample Data

The `init.sql` script includes:
- 6 predefined categories (Work, Personal, Studies, Projects, Ideas, Shopping)
- 10 sample notes with their respective categories

## API Endpoints

### Notes

| Method | Endpoint | Description |
|--------|----------|-------------|
| GET | `/notes` | List all notes |
| POST | `/notes` | Create a new note |
| PUT | `/notes/:id` | Update a note |
| DELETE | `/notes/:id` | Delete a note |

### Categories

| Method | Endpoint | Description |
|--------|----------|-------------|
| GET | `/categories` | List all categories |
| POST | `/categories` | Create a new category |
| DELETE | `/categories/:id` | Delete a category |

## Environment Variables

### Backend (`backend/DBManager/util/mysql.env`)

```env
DB_HOST=localhost
DB_PORT=3306
DB_USER=root
DB_NAME=notes_app
DB_PASSWORD=password
```

**Note:** Backend port (1234) is hardcoded in `app.ts`.

### Frontend (`frontend/todo-app/.env`)

```env
VITE_API_URL=http://localhost:1234
```

## Troubleshooting


### Error: "MySQL not found"

```bash
# Check if MySQL is installed
mysql --version

# Start MySQL service
# On macOS:
brew services start mysql

# On Linux (Ubuntu/Debian):
sudo systemctl start mysql

# On Windows (using WSL):
sudo service mysql start
```

### Error: "Cannot connect to MySQL server"

Make sure MySQL service is running:

```bash
# Check MySQL status
# On macOS:
brew services list | grep mysql

# On Linux:
sudo systemctl status mysql

# Start if not running
# On macOS:
brew services start mysql

# On Linux:
sudo systemctl start mysql
```

### Error: "Port 1234 already in use"

Port 1234 is hardcoded in `backend/app.ts`. To change it:

1. Edit `backend/app.ts` and modify the PORT constant
2. Update `frontend/todo-app/.env` with the new URL

### Error executing setup.sh on Windows

Use Git Bash or WSL (Windows Subsystem for Linux). PowerShell and CMD are not supported.

```bash
# Using Git Bash
bash setup.sh

# Using WSL
wsl bash setup.sh
```

### Error: "Cannot find module" when running backend

Make sure you've installed dependencies:

```bash
cd backend
npm install
```

### Frontend not connecting to backend

1. Check that backend is running on port 1234
2. Verify `frontend/todo-app/.env` has the correct API URL
3. Check browser console for CORS errors
4. Make sure both services are running

## Additional Notes

- `.env` and `mysql.env` files should not be committed to git (they're in `.gitignore`)
- Backend uses TypeScript with ts-node to run directly without compilation
- Frontend uses Vite for fast development with HMR (Hot Module Replacement)
- Database is initialized with sample data for testing purposes
- Backend port 1234 is defined in `app.ts`
- The backend does not support MySQL passwords by default

## Development Commands

```bash
# Backend
cd backend
npm start              # Start development server

# Frontend
cd frontend/todo-app
npm run dev           # Start development server with Vite
npm run build         # Build for production
npm run preview       # Preview production build
```

## 📄 License

ISC
````

## .gitignore

```text
# ============================================
# DEPENDENCIAS
# ============================================
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

# ============================================
# VARIABLES DE ENTORNO (CREDENCIALES)
# ============================================
# Archivos de entorno generales
.env
.env.local
.env.*.local
.env.production
.env.development

# Backend - MySQL configuration
**/DBManager/util/mysql.env

# Frontend - Vite environment
frontend/todo-app/.env
frontend/todo-app/.env.local
frontend/todo-app/.env.*.local

# ============================================
# ARCHIVOS DE BUILD Y DIST
# ============================================
# Frontend (Vite/React)
dist/
dist-ssr/
build/
*.local

# Backend (TypeScript compilation)
backend/dist/
backend/build/
*.tsbuildinfo

# ============================================
# EDITORES E IDEs
# ============================================
# Visual Studio Code
.vscode/
.vscode/*
!.vscode/extensions.json
!.vscode/settings.json.example
.history/

# JetBrains IDEs (WebStorm, IntelliJ)
.idea/
*.iml
*.iws
*.ipr
out/

# Sublime Text
*.sublime-project
*.sublime-workspace

# Vim
*.swp
*.swo
*~
.*.sw[a-z]

# Emacs
*~
\#*\#
.\#*

# ============================================
# SISTEMA OPERATIVO
# ============================================
# macOS
.DS_Store
.AppleDouble
.LSOverride
._*
.Spotlight-V100
.Trashes

# Windows
Thumbs.db
Thumbs.db:encryptable
ehthumbs.db
ehthumbs_vista.db
Desktop.ini
$RECYCLE.BIN/

# Linux
*~
.directory
.Trash-*

# ============================================
# LOGS Y TEMPORALES
# ============================================
*.log
logs/
*.pid
*.seed
*.pid.lock
.pnp.*
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# ============================================
# TESTING Y COVERAGE
# ============================================
coverage/
*.lcov
.nyc_output/
lib-cov/
.grunt/
.lock-wscript

# ============================================
# TYPESCRIPT
# ============================================
*.tsbuildinfo
*.js.map
*.d.ts.map

# ============================================
# RUNTIME Y CACHE
# ============================================
.cache/
.parcel-cache/
.vite/
.temp/
.tmp/

# ============================================
# OTROS
# ============================================
# Backup files
*.bak
*.backup
*.old

# Compressed files (si no son necesarios)
*.zip
*.tar
*.gz
*.rar

# Certificados y keys (seguridad)
*.pem
*.key
*.cert
*.crt

# Archivos de base de datos locales
*.sqlite
*.sqlite3
*.db
```

## Statistics

- Total Files: 44
- Total Characters: 107288
- Total Tokens: 0
